//report.txt
//Lab 5
//By: Andy Munch

	The user begins by running the executable and is presented with a prompt to enter a file name that contains the text of the original board. This board is then presented in the form of a soduku board.  The user is then prompted to input a number from 1 to 9, and then input the row and the column of the desired place to place the value.  The board is then displayed with this new value if this was a valid move, and this continues until the board is won, in which case the program will exit.
	Internally, the main structure of this program is a templated class. This class is templated such that we can input both chars and ints, as the input and print of these boards is the same.  The nondefault constructor for this class works by first prompting the user for the file name containing the original board and then opening this file using the open function.  I then looped through this file until the EOF character was reached, and placed these values into the 2D array.  I achieved this by using the pushback function to make a temporary vector and then pushing this vector into the vector of vectors. I then cleared the temporary vector and repeated this for every row until all values are inputted.
	I then declared a print function that prints all of the values to the screen, and for every third column places bars to separate and dashes for every third row to create a hastag of sorts.  
	Next, I have a place function that places a value on the board if the player has created a valid move.  I do this by continually looping through a prompt that has the user input the number, row and column, and then checking these, and keep prompting until a user's input is valid.  First, I checked to make sure that the inputs was a number between 1 and 9. Next, I made sure that the number was not overwriting one of the original values.  Next, I checked to make sure that the value was valid according to the sudoku rules, as discussed in the next paragraph.
	For the check function, I first looped through all row values and column values correponsding to the placement of the user's inputted value.  I then checked the mini grid by first finding what grid the number is being attempted to be placed into.  I achieved this casting the row value divided by three into an int, and this will give the lower value of the mini-grid row and column corresponding to the values position on the three by three mini grid.  I then checked to see if any of the values in the sub square was equal to the value inputted, and if this did not occur, this was a valid move.
	For the win function, I simply looped through the board to see if there were any 0's. If not, then clearly the board was won, and I did not have to check if the board was correct because this was taken care of every time the user inputted a value.
	Within main, I instantiated a puzzle object, printed it to the screen, and then called the place function while the game was not won.  Once the game is one, I exited succesfully and outputted that the user has won.
	Verification was primarily done by repeatedly playing the game and fixing any errors that occurred.  This was primarily done by inputting a number and then manually checking if it was valid.  I also tested values that I knew were wrong and checked to see that the correct error was being thrown.  Any inconstencies were fixed quickly.
	I think that value checking functions worked well except for checking for the mini grid, which eventually got a little sloppy.  Using a vector of vectors is unnatural, but once I got the hang of it I think it is a great way to represent a 2D array.  In general, I think that templating was fantastic for working with print functions and taking in either a char or an int.  It really cut down on the code and made it concise and easier to use as a programmer.  However, when it came to actually playing a game, it quickly lost its effectiveness as you have to deal with chars and ints very differently when it comes to playing sudoku.
	My discussion of part 2 goes in depth above, particulary when I describe the check functions. Overall, I found it natural and simple to check the same row and column the value was in, and fairly easy to check the mini grids using the modulus operator.  At the heart of it is finding what exactly to loop through and check each time a value is implemented, and once this is planned ahead, it is not difficult to implement these checks.
